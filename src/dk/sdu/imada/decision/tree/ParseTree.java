/*
 *            	Life-Style-Specific-Islands
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *      
 * This material was developed as part of a research project at 
 * the University of Southern Denmark (SDU - Odense, Denmark) 
 * and the Federal University of Minas Gerais (UFMG - Belo 
 * Horizonte, Brazil). For more information please access:
 * 
 *      	https://lissi.compbio.sdu.dk/ 
 */
package dk.sdu.imada.decision.tree;


import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.MathContext;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import dk.sdu.imada.decision.tree.TreeNode.ScoreDistribution;
import dk.sdu.imada.methods.Parser;


/**
 * Class parses decision tree information from XML file 
 * generated by the Rscripts processes.
 * 
 * @author Eudes Barbosa	
 */
public class ParseTree extends Parser {
	
	//------  Variable declaration  ------//

	private static final Logger logger = LogManager.getLogger(ParseTree.class.getName());

	/** Array containing all nodes found in the decision tree file. */
	protected ArrayList<TreeNode> nodes = new ArrayList<>();

	/** 
	 * HashMap to access tree structure. It associates the child node 
	 * identifier (String - Key) with the parent identifier (String - Value).
	 */
	protected LinkedHashMap<String, String> mappedTree = 
			new LinkedHashMap<String, String>();

	/** True lifestyle one (True Positive - TP). */
	protected int tL1 = 0;

	/** False lifestyle one (False Positive - FP). */
	protected int fL1 = 0;

	/** True lifestyle two (True Negative - TN). */
	protected int tL2 = 0;

	/** False lifestyle two (False Negative - FN). */
	protected int fL2 = 0;

	//------  Declaration end  ------//

	/**
	 * Parses the information from the tree generated 
	 * by R. It expects the file to be in xml format. 
	 * 
	 * @param file		Path to the file containing the 
	 * 					tree information (xml format).
	 */
	public ParseTree(String file) {
		// Parse file and add mapped information
		parse(file);
		addTreeStructure();
		//
		//printTree();
	}	

	/**
	 * Calculate values necessary for Sensitivity, 
	 * Specificity and Accuracy. Note: it expects 
	 * that the class has already parsed the tree 
	 * file (xml format).
	 */
	public void calculateValuesStatisticalFunctions() {
		// Both are not required but makes it easier to understand...
		String lifestyleOne = nodes.get(0).getScores().get(0).getLifestyle();
		String lifestyleTwo = nodes.get(0).getScores().get(1).getLifestyle();

		// Iterate
		for (TreeNode tn : nodes) {
			if(tn.hasChild() == false) {
				if (tn.getClassification().equals(lifestyleOne)) {
					for (int i = 0; i < 2; i++){
						if (tn.getScores().get(i).getLifestyle().equals(lifestyleOne)) {
							tL1 += tn.getScores().get(i).getCount();				
						} else {
							fL1 += tn.getScores().get(i).getCount();
						}
					}				
				} else if (tn.getClassification().equals(lifestyleTwo)) {
					for (int i = 0; i < 2; i++){
						if (tn.getScores().get(i).getLifestyle().equals(lifestyleTwo)) {
							tL2 += tn.getScores().get(i).getCount();				
						} else {
							fL2 += tn.getScores().get(i).getCount();
						}
					}
				}
			}
		}
	}

	/** @return	Returns decision tree Sensitivity. */
	public BigDecimal getSensitivity() {
		BigDecimal tp = new BigDecimal(tL1);
		BigDecimal frac = tp.divide(tp.add(new BigDecimal(fL2)), MathContext.DECIMAL128);
		return frac.multiply(new BigDecimal(100));
	}

	/** @return	Returns decision tree Specificity. */
	public BigDecimal getSpecificity() {
		BigDecimal tp = new BigDecimal(tL2);
		BigDecimal frac = tp.divide(tp.add(new BigDecimal(fL1)), MathContext.DECIMAL128);
		return frac.multiply(new BigDecimal(100));
	}

	/** @return	Returns decision tree Accuracy. */
	public BigDecimal getAccuracy() {
		BigDecimal numerator = new BigDecimal(tL2).add(new BigDecimal(tL1));
		BigDecimal denominator = new BigDecimal(fL1).add(new BigDecimal(fL2)).add(numerator);
		BigDecimal result = numerator.divide(denominator, MathContext.DECIMAL128);
		return result.multiply(new BigDecimal(100));
	}

	/**
	 * Parses the information from the tree generated 
	 * by R. It expects the file to be in csv format 
	 * (tabular), and that the class has already 
	 * parsed the tree file (xml format).
	 * 
	 * @param file		Path to the file containing the 
	 * 					node mean decrease Gini index 
	 * 					(csv format).
	 */
	public LinkedHashMap<String, String> getMeanDecreaseGini(String file) {
		// Final Map with tree's gini indexes
		LinkedHashMap<String, String> mappedGini = 
				new LinkedHashMap<String, String>();
		// Map with all gini indexes
		HashMap<String, String> mappedNodeGini = getNodeGini(file);
		// Map with nodes and idenfiers
		HashMap<String, TreeNode> mappedNodes = 
				new HashMap<String, TreeNode>();
		for (TreeNode tn : nodes) {
			mappedNodes.put(tn.getId(), tn);
		}		
		// Iterate through nodes
		for (TreeNode tn : nodes) {			
			if (tn.hasChild()) {
				String child = tn.getDefaultChildID();
				TreeNode tnClhild = mappedNodes.get(child);
				String parsedField = parseNodeField(tnClhild.getNodeField());
				String gini = mappedNodeGini.get(parsedField);
				mappedGini.put(tn.getId() , gini);
			}
		}		
		//
		return mappedGini;
	}

	/**
	 * @param node	Node field.
	 * @return		Returns the parsed node field.
	 */
	private String parseNodeField(String node) {
		// Parse field if necessary
		String clusterID = node;
		if (clusterID.contains("|")) {
			String[] data = clusterID.split("\\|");
			clusterID = data[0];
		}
		clusterID = clusterID.replaceAll("ID\\.", "");
		//
		return clusterID;
	}

	/** 
	 * @param file		Path to the file containing the 
	 * 					node mean decrease Gini index 
	 * 					(csv format).
	 * 
	 * @return	Returns a map with the node identifier (feature) as Key, 
	 * 			and the mean decrease Gini index as Value. 
	 */
	private HashMap<String, String> getNodeGini(String file) {
		HashMap<String, String> mappedNodeGini = 
				new HashMap<String, String>();
		// Load file
		BufferedReader br;
		String stringLine;
		try {
			// Buffer and read file
			br = getBufferedReader(file);
			while ((stringLine = br.readLine()) != null) {
				String[] data = stringLine.split("\t");
				String feature = data[0].replaceAll("X", "");
				//
				double gini = Double.parseDouble(data[1]);
				String value =  String.format("%.3g%n", gini);
				mappedNodeGini.put(feature, value);
			}
			br.close();
		} catch (IOException e) {
			logger.info("FileNotFoundException: " + e);		
		}
		return mappedNodeGini;
	}

	/**
	 * Adds structure to the tree, i.e., informes 
	 * if a node has a parent.
	 */
	protected void addTreeStructure() {
		for (TreeNode n : nodes) {
			String id = n.getId();
			// Root always has id=1
			if (!id.equals("1")) { //ignore root
				String parent = mappedTree.get(id);
				n.setImmediateParent(parent);
			}			 
		}			
	}

	/**
	 * Parses the tree file (xml) and reports the 
	 * information of all nodes. The results will be 
	 * stored in a array of nodes (class variable).
	 * 
	 * @param path		Path to tree file.
	 */
	protected void parse(String path) {
		// Get nodes
		NodeList nList = getNodeList(path, "Node");		

		// Iterate through nodes (get info)
		for (int i = 0; i < nList.getLength(); i++) {
			//
			TreeNode dt = new TreeNode();			
			//
			Node n = nList.item(i);
			Element eElement = (Element) n;

			// Get node information
			String id = eElement.getAttribute("id");
			dt.setId(id);
			dt.setClassification(eElement.getAttribute("score"));
			dt.setTotal(Integer.parseInt(eElement.getAttribute("recordCount")));		
			dt.setDefaultChildID(eElement.getAttribute("defaultChild"));

			// Get child nodes information
			NodeList children = eElement.getChildNodes();
			Node current = null;
			int count = children.getLength();
			for (int j = 0; j < count; j++) {
				ScoreDistribution sd = new ScoreDistribution();
				//
				current = children.item(j);
				if (current.getNodeType() == Node.ELEMENT_NODE) {
					Element element = (Element) current;
					// Score Distribution
					if (element.getNodeName().equalsIgnoreCase("ScoreDistribution")) {
						sd.setLifestyle(element.getAttributeNode("value")
								.getTextContent());
						sd.setCount(Integer.parseInt(element.getAttributeNode("recordCount")
								.getTextContent()));
						sd.setConfidence(element.getAttributeNode("confidence").getTextContent());
						dt.addScores(sd);
					}					
					// Simple or Compound Predicate
					if (element.getNodeName().equalsIgnoreCase("SimpleSetPredicate")) {
						dt.setNodeField(element.getAttributeNode("field")
								.getTextContent().replace("X", "ID."));
						// Get operator
						NodeList fields = element.getChildNodes();
						int countField = fields.getLength();
						Node currentField = null;
						for (int l = 0; l < countField; l++) {
							currentField = fields.item(l);
							if (currentField.getNodeType() == Node.ELEMENT_NODE 
									&& currentField.getNodeName().equalsIgnoreCase("Array")) {
								Element elementField = (Element) currentField;
								dt.setOperator(elementField.getTextContent().replace("\"", ""));								
							}
						}						
					} else if (element.getNodeName().equalsIgnoreCase("CompoundPredicate")) {
						// If Compound predicate, it is necessary go to another 
						// level of child nodes.
						NodeList fields = element.getChildNodes();
						int countField = fields.getLength();
						String composeField = "";
						Node currentField = null;
						// Extract compose field (more than one cluster/island)
						for (int l = 0; l < countField; l++) {
							currentField = fields.item(l);
							if (currentField.getNodeType() == Node.ELEMENT_NODE) {
								Element elementField = (Element) currentField;
								if (elementField.getNodeName()
										.equalsIgnoreCase("SimpleSetPredicate")) {
									composeField += elementField.getAttributeNode("field")
											.getTextContent()
											.replace("X", "ID.")
											.concat("|");
								}								
								/* Extract operator
								 * (working under the assumption that they go 
								 * on the same direction, always)*/
								// Get operator
								NodeList fields2 = element.getChildNodes();
								int countField2 = fields2.getLength();
								Node currentField2 = null;
								for (int m = 0; m < countField2; m++) {
									currentField2 = fields2.item(m);
									if (currentField2.getNodeType() == Node.ELEMENT_NODE 
											&& currentField2.getNodeName().equalsIgnoreCase("Array")) {
										Element elementField2 = (Element) currentField2;
										dt.setOperator(elementField2.getTextContent().replace("\"", ""));								
									}
								}
							}
						}
						// Add compose field
						dt.setNodeField(composeField);
					}
					// Get child nodes
					if (element.getNodeName().equalsIgnoreCase("Node")) {
						String childID = element.getAttributeNode("id").getTextContent();
						dt.setHasChild(true);
						// Add to map
						mappedTree.put(childID, id);
					} else {
						dt.setHasChild(false);
					}
				}
			}
			// Add to list
			nodes.add(dt);
		}
	}

	/**
	 * Reads the tree file (xml) and reports all nodes. 
	 * @return			Returns nodes within Tree file.
	 */
	protected NodeList getNodeList(String file, String field) {
		//
		NodeList nList = null;
		// Read XML file
		try {	
			File xmlFile = new File(file);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(xmlFile);
			// Remove spaces and line breaks from fields
			doc.getDocumentElement().normalize();
			// Get nodes information
			nList = doc.getElementsByTagName(field);
		} catch (Exception e) {
			//if (ViewRFOutput.getStatus() ==  false) {
				logger.error("Failed to read tree file (xml). ");
				e.printStackTrace();
			//}
		}
		//
		return nList;
	}

	/**
	 * @return		Returns array with information 
	 * 				from nodes from decision tree.
	 */
	public ArrayList<TreeNode> getNodes() {
		return nodes;
	}

	/** Print tree info (testing). */	
	@SuppressWarnings("unused")
	private void printTree() {
		for (TreeNode tn : nodes) {
			System.out.println(tn.getId()
					+ "\t"+ tn.getNodeField()
					+ "\t"+ tn.getOperator());
		}
	}
}